
//=============================================================================
//                     JISON-LEX OPTIONS:

{
  lexerActionsUseYYLENG: '???',
  lexerActionsUseYYLINENO: '???',
  lexerActionsUseYYTEXT: '???',
  lexerActionsUseYYLOC: '???',
  lexerActionsUseParseError: '???',
  lexerActionsUseYYERROR: '???',
  lexerActionsUseLocationTracking: '???',
  lexerActionsUseMore: '???',
  lexerActionsUseUnput: '???',
  lexerActionsUseReject: '???',
  lexerActionsUseLess: '???',
  lexerActionsUseDisplayAPIs: '???',
  lexerActionsUseDescribeYYLOC: '???',
  lex_rule_dictionary: {
    rules: [
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `yytext = '';
        this.popState();
        return 'areaEnd'`,
        rule: '(\\/\\/\\n)',
        start_condition: [
          'area',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "this.popState();\n        return 'areaEnd'",
        rule: '(?=(\\/\\/|\\/\\*))',
        start_condition: [
          'area',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'areaString'",
        rule: '(.|{lineEnd})',
        start_condition: [
          'area',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "this.popState();\n        return 'areaEnd'",
        rule: '(?=$)',
        start_condition: [
          'area',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `this.begin('area');
        yytext = getTypes(yytext.substring(2, yyleng));
        return 'areaType'`,
        rule: '(\\/\\/){commentName}(?={lineEnd})',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "this.popState();\n        return 'commentEnd'",
        rule: '(\\*\\/)',
        start_condition: [
          'commentBody',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'bodyString'",
        rule: '(.|{lineEnd})',
        start_condition: [
          'commentBody',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `this.begin('commentBody');
        yytext = getTypes(yytext.substring(2, yyleng));
        return 'commentType'`,
        rule: '(\\/\\*){commentName}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'inlineBodyString'",
        rule: '(.)',
        start_condition: [
          'inlineCommentBody',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "this.popState();\n        return 'inlineCommentEnd'",
        rule: '(?={lineEnd})',
        start_condition: [
          'inlineCommentBody',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "this.popState();\n        return 'inlineCommentEnd'",
        rule: '(?=$)',
        start_condition: [
          'inlineCommentBody',
        ],
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `this.begin('inlineCommentBody');
        yytext = getTypes(yytext.substring(2, yyleng));
        return 'inlineCommentType'`,
        rule: '\\/\\/{commentName}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'string'",
        rule: '([A-Za-z0-9 .,?;]+)',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'string'",
        rule: '([ ])',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'string'",
        rule: '{lineEnd}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'string'",
        rule: '(.)',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'eof'",
        rule: '$',
      },
    ],
    macros: {
      lineEnd: '(\\n\\r|\\r\\n|[\\n\\r])',
      commentName: '([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))',
    },
    startConditions: {
      area: 0,
      commentBody: 0,
      inlineCommentBody: 0,
    },
    codeSections: [],
    importDecls: [],
    unknownDecls: [],
    actionInclude: `// Included by Jison: includes/comments.helpers.js:

// helper APIs for testing the comments.l lexer spec

function getTypes(str) {
	return 'T:' + str;
}

// End Of Include by Jison: includes/comments.helpers.js`,
  },
  codeSections: [],
  importDecls: [],
  unknownDecls: [],
  options: {
    moduleType: 'commonjs',
    debug: false,
    enableDebugLogs: false,
    json: true,
    noMain: true,
    moduleMain: null,
    moduleMainImports: null,
    dumpSourceCodeOnFailure: false,
    throwErrorOnCompileFailure: true,
    doNotTestCompile: false,
    defaultModuleName: 'lexer',
    xregexp: false,
    lexerErrorsAreRecoverable: false,
    flex: false,
    backtrack_lexer: false,
    ranges: false,
    trackPosition: true,
    caseInsensitive: false,
    exportSourceCode: {
      enabled: false,
    },
    exportAST: false,
    prettyCfg: true,
  },
  conditions: {
    area: {
      rules: [
        0,
        1,
        2,
        3,
        4,
        7,
        11,
        12,
        13,
        14,
        15,
        16,
      ],
      inclusive: true,
    },
    commentBody: {
      rules: [
        4,
        5,
        6,
        7,
        11,
        12,
        13,
        14,
        15,
        16,
      ],
      inclusive: true,
    },
    inlineCommentBody: {
      rules: [
        4,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
      ],
      inclusive: true,
    },
    INITIAL: {
      rules: [
        4,
        7,
        11,
        12,
        13,
        14,
        15,
        16,
      ],
      inclusive: true,
    },
  },
  performAction: `function lexer__performAction(yy, yyrulenumber, YY_START) {
            const yy_ = this;

            // Included by Jison: includes/comments.helpers.js:

// helper APIs for testing the comments.l lexer spec

function getTypes(str) {
	return 'T:' + str;
}

// End Of Include by Jison: includes/comments.helpers.js
const YYSTATE = YY_START;
switch(yyrulenumber) {
case 0 : 
/*! Conditions:: area */ 
/*! Rule::       (\\/\\/\\n) */ 
 yy_.yytext = '';
        this.popState();
        return 'areaEnd' 
break;
case 1 : 
/*! Conditions:: area */ 
/*! Rule::       (?=(\\/\\/|\\/\\*)) */ 
 this.popState();
        return 'areaEnd' 
break;
case 3 : 
/*! Conditions:: area */ 
/*! Rule::       (?=$) */ 
 this.popState();
        return 'areaEnd' 
break;
case 4 : 
/*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
/*! Rule::       (\\/\\/){commentName}(?={lineEnd}) */ 
 this.begin('area');
        yy_.yytext = getTypes(yy_.yytext.substring(2, yy_.yyleng));
        return 'areaType' 
break;
case 5 : 
/*! Conditions:: commentBody */ 
/*! Rule::       (\\*\\/) */ 
 this.popState();
        return 'commentEnd' 
break;
case 7 : 
/*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
/*! Rule::       (\\/\\*){commentName} */ 
 this.begin('commentBody');
        yy_.yytext = getTypes(yy_.yytext.substring(2, yy_.yyleng));
        return 'commentType' 
break;
case 9 : 
/*! Conditions:: inlineCommentBody */ 
/*! Rule::       (?={lineEnd}) */ 
 this.popState();
        return 'inlineCommentEnd' 
break;
case 10 : 
/*! Conditions:: inlineCommentBody */ 
/*! Rule::       (?=$) */ 
 this.popState();
        return 'inlineCommentEnd' 
break;
case 11 : 
/*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
/*! Rule::       \\/\\/{commentName} */ 
 this.begin('inlineCommentBody');
        yy_.yytext = getTypes(yy_.yytext.substring(2, yy_.yyleng));
        return 'inlineCommentType' 
break;
default:
  return this.simpleCaseActionClusters[yyrulenumber];
}
        }`,
  caseHelperInclude: `{

  /*! Conditions:: area */ 
  /*! Rule::       (.|{lineEnd}) */ 
   2 : 'areaString',
  /*! Conditions:: commentBody */ 
  /*! Rule::       (.|{lineEnd}) */ 
   6 : 'bodyString',
  /*! Conditions:: inlineCommentBody */ 
  /*! Rule::       (.) */ 
   8 : 'inlineBodyString',
  /*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
  /*! Rule::       ([A-Za-z0-9 .,?;]+) */ 
   12 : 'string',
  /*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
  /*! Rule::       ([ ]) */ 
   13 : 'string',
  /*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
  /*! Rule::       {lineEnd} */ 
   14 : 'string',
  /*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
  /*! Rule::       (.) */ 
   15 : 'string',
  /*! Conditions:: area commentBody inlineCommentBody INITIAL */ 
  /*! Rule::       $ */ 
   16 : 'eof'
}`,
  rules: [
    {
      re: '/^(?:(\\/\\/\\n))/',
      source: '^(?:(\\/\\/\\n))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(\\/\\/\\n))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(?=(\\/\\/|\\/\\*)))/',
      source: '^(?:(?=(\\/\\/|\\/\\*)))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(?=(\\/\\/|\\/\\*)))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))/',
      source: '^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(?=$))/',
      source: '^(?:(?=$))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(?=$))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(\\/\\/)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*)))(?=((\\n\\r|\\r\\n|[\\n\\r]))))/',
      source: '^(?:(\\/\\/)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*)))(?=((\\n\\r|\\r\\n|[\\n\\r]))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(\\/\\/)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*)))(?=((\\n\\r|\\r\\n|[\\n\\r]))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(\\*\\/))/',
      source: '^(?:(\\*\\/))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(\\*\\/))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))/',
      source: '^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(.|((\\n\\r|\\r\\n|[\\n\\r]))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(\\/\\*)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))/',
      source: '^(?:(\\/\\*)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(\\/\\*)(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(.))/',
      source: '^(?:(.))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(.))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(?=((\\n\\r|\\r\\n|[\\n\\r]))))/',
      source: '^(?:(?=((\\n\\r|\\r\\n|[\\n\\r]))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(?=((\\n\\r|\\r\\n|[\\n\\r]))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(?=$))/',
      source: '^(?:(?=$))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(?=$))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\/\\/(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))/',
      source: '^(?:\\/\\/(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\/\\/(([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:([A-Za-z0-9 .,?;]+))/',
      source: '^(?:([A-Za-z0-9 .,?;]+))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:([A-Za-z0-9 .,?;]+))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:([ ]))/',
      source: '^(?:([ ]))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:([ ]))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:((\\n\\r|\\r\\n|[\\n\\r])))/',
      source: '^(?:((\\n\\r|\\r\\n|[\\n\\r])))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:((\\n\\r|\\r\\n|[\\n\\r])))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(.))/',
      source: '^(?:(.))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(.))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:$)/',
      source: '^(?:$)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:$)',
        flags: '',
        isNative: true,
      },
    },
  ],
  macros: {
    lineEnd: {
      in_set: {
        message: '[macro [lineEnd] is unsuitable for use inside regex set expressions: "[(\\n\\r|\\r\\n|[\\n\\r])]"]',
        name: 'Error',
      },
      elsewhere: '(\\n\\r|\\r\\n|[\\n\\r])',
      raw: '(\\n\\r|\\r\\n|[\\n\\r])',
    },
    commentName: {
      in_set: {
        message: '[macro [commentName] is unsuitable for use inside regex set expressions: "[([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))]"]',
        name: 'Error',
      },
      elsewhere: '([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))',
      raw: '([a-zA-Z]+(\\||[a-zA-Z]+)*(?=[\\s]*))',
    },
  },
  regular_rule_count: 9,
  simple_rule_count: 8,
  conditionStack: [
    'INITIAL',
  ],
  actionInclude: `// Included by Jison: includes/comments.helpers.js:

// helper APIs for testing the comments.l lexer spec

function getTypes(str) {
	return 'T:' + str;
}

// End Of Include by Jison: includes/comments.helpers.js`,
  moduleInclude: '',
  __in_rules_failure_analysis_mode__: false,
  is_custom_lexer: false,
}