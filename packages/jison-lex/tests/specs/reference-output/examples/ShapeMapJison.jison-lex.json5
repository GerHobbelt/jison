
//=============================================================================
//                     JISON-LEX OPTIONS:

{
  lexerActionsUseYYLENG: '???',
  lexerActionsUseYYLINENO: '???',
  lexerActionsUseYYTEXT: '???',
  lexerActionsUseYYLOC: '???',
  lexerActionsUseParseError: '???',
  lexerActionsUseYYERROR: '???',
  lexerActionsUseLocationTracking: '???',
  lexerActionsUseMore: '???',
  lexerActionsUseUnput: '???',
  lexerActionsUseReject: '???',
  lexerActionsUseLess: '???',
  lexerActionsUseDisplayAPIs: '???',
  lexerActionsUseDescribeYYLOC: '???',
  lex_rule_dictionary: {
    rules: [
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: '/**/',
        rule: '\\s+|{COMMENT}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'APPINFO_SPACE_COLON'",
        rule: '{APPINFO_SPACE_COLON}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'STRING_LITERAL2_COLON'",
        rule: '{STRING_LITERAL2_COLON}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_FOCUS'",
        rule: '{FOCUS}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'START'",
        rule: '{START}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'ATSTART'",
        rule: '{ATSTART}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_SPARQL'",
        rule: '{IT_SPARQL}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'ATPNAME_LN'",
        rule: '{ATPNAME_LN}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'ATPNAME_NS'",
        rule: '{ATPNAME_NS}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'LANGTAG'",
        rule: '{LANGTAG}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'PNAME_LN'",
        rule: '{PNAME_LN}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'APPINFO_COLON'",
        rule: '{APPINFO_COLON}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'PNAME_NS'",
        rule: '{PNAME_NS}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'DOUBLE'",
        rule: '{DOUBLE}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'DECIMAL'",
        rule: '{DECIMAL}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'INTEGER'",
        rule: '{INTEGER}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IRIREF'",
        rule: '{IRIREF}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'BLANK_NODE_LABEL'",
        rule: '{BLANK_NODE_LABEL}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'STRING_LITERAL_LONG1'",
        rule: '{STRING_LITERAL_LONG1}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'STRING_LITERAL_LONG2'",
        rule: '{STRING_LITERAL_LONG2}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'STRING_LITERAL1'",
        rule: '{STRING_LITERAL1}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'STRING_LITERAL2'",
        rule: '{STRING_LITERAL2}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_a'",
        rule: 'a',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_COMMA'",
        rule: ',',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_LCURLEY'",
        rule: '\\{',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_RCURLEY'",
        rule: '\\}',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_AT'",
        rule: '@',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_NOT'",
        rule: '!',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_OPT'",
        rule: '\\?',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_DIVIDE'",
        rule: '\\/',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_DOLLAR'",
        rule: '\\$',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_LBRACKET'",
        rule: '\\[',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_RBRACKET'",
        rule: '\\]',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'GT_DTYPE'",
        rule: '\\^\\^',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT__'",
        rule: '_',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_true'",
        rule: 'true',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_false'",
        rule: 'false',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'IT_null'",
        rule: 'null',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'EOF'",
        rule: '$',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `return 'unexpected word "'+yytext+'"'`,
        rule: '[a-zA-Z0-9_-]+',
      },
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: "return 'invalid character '+yytext",
        rule: '.',
      },
    ],
    macros: {
      APPINFO_COLON: 'appinfo:',
      APPINFO_SPACE_COLON: 'appinfo[\\u0020\\u000A\\u0009]+:',
      STRING_LITERAL2_COLON: '"([^\\u0022\\u005C\\u000A\\u000D]|{ECHAR}|{UCHAR})*"[\\u0020\\u000A\\u0009]*:',
      FOCUS: '[Ff][Oo][Cc][Uu][Ss]',
      START: '[Ss][Tt][Aa][Rr][Tt]',
      ATSTART: '@[Ss][Tt][Aa][Rr][Tt]',
      IT_SPARQL: '[Ss][Pp][Aa][Rr][Qq][Ll]',
      LANGTAG: '@([A-Za-z])+((-([0-9A-Za-z])+))*',
      INTEGER: '([+-])?([0-9])+',
      DECIMAL: '([+-])?([0-9])*\\.([0-9])+',
      EXPONENT: '[Ee]([+-])?([0-9])+',
      DOUBLE: '([+-])?((([0-9])+\\.([0-9])*({EXPONENT}))|((\\.)?([0-9])+({EXPONENT})))',
      ECHAR: '\\\\[\\"\\\'\\\\bfnrt]',
      PN_CHARS_BASE: '[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]',
      PN_CHARS_U: '{PN_CHARS_BASE}|_|_',
      PN_CHARS: '{PN_CHARS_U}|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]',
      BLANK_NODE_LABEL: '_:({PN_CHARS_U}|[0-9])(({PN_CHARS}|\\.)*{PN_CHARS})?',
      PN_PREFIX: '{PN_CHARS_BASE}(({PN_CHARS}|\\.)*{PN_CHARS})?',
      PNAME_NS: '{PN_PREFIX}?:',
      ATPNAME_NS: '@{PNAME_NS}',
      HEX: '[0-9]|[A-F]|[a-f]',
      PERCENT: '%{HEX}{HEX}',
      UCHAR: '\\\\u{HEX}{HEX}{HEX}{HEX}|\\\\U{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}',
      STRING_LITERAL1: "'([^\\u0027\\u005c\\u000a\\u000d]|{ECHAR}|{UCHAR})*'",
      STRING_LITERAL2: '"([^\\u0022\\u005c\\u000a\\u000d]|{ECHAR}|{UCHAR})*"',
      STRING_LITERAL_LONG1: `'''(('|'')?([^\\'\\\\]|{ECHAR}|{UCHAR}))*'''`,
      STRING_LITERAL_LONG2: `"""(("|"")?([^\\"\\\\]|{ECHAR}|{UCHAR}))*"""`,
      IRIREF: '<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|{UCHAR})*>',
      PN_LOCAL_ESC: "\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)",
      PLX: '{PERCENT}|{PN_LOCAL_ESC}',
      PN_LOCAL: '({PN_CHARS_U}|:|[0-9]|{PLX})({PN_CHARS}|\\.|:|{PLX})*',
      PNAME_LN: '{PNAME_NS}{PN_LOCAL}',
      ATPNAME_LN: '@{PNAME_LN}',
      COMMENT: '#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/',
    },
    startConditions: {},
    codeSections: [
      {
        qualifier: 'init',
        include: `// Included by Jison: includes/unicode.helpers.js:

// helper APIs for testing the unicode*.jisonlex lexer specs

// WARNING: this stuff is purely here so the example(s) will pass the default run test. You mileage will be NIL on these!

let predictive_random_seed = 5;

function getSemiRandomNumber() {
	predictive_random_seed = (predictive_random_seed * 31 + 7) % 51;	
	return predictive_random_seed;
}

// these are used in a three-way test in unicode2 spec:
function is_constant(str) {
	return getSemiRandomNumber() % 3 === 1;
}
function is_function(str) {
	return getSemiRandomNumber() % 3 === 2;
}



const FERR_UNTERMINATED_INLINE_COMMENT = 0x0100;
const FKA_COMMA = 0x0101;
const FKA_FIXED_ROW_OR_COLUMN_MARKER = 0x0102;
const FKA_RANGE_MARKER = 0x0103;
const FKW_ADD = 0x0104;
const FKW_ALMOST_EQUAL = 0x0105;
const FKW_ARRAY_CONCATENATION_OPERATOR = 0x0106;
const FKW_BOOLEAN_AND_OPERATOR = 0x0107;
const FKW_BOOLEAN_NOT_OPERATOR = 0x0108;
const FKW_BOOLEAN_OR_OPERATOR = 0x0109;
const FKW_CUBE_OPERATOR = 0x010A;
const FKW_DATA_MARKER = 0x010B;
const FKW_DEGREES_OPERATOR = 0x010C;
const FKW_DIVIDE = 0x010D;
const FKW_DOT = 0x010E;
const FKW_EQUAL = 0x010F;
const FKW_GREATER_OR_EQUAL = 0x0110;
const FKW_GREATER_THAN = 0x0111;
const FKW_IS_IDENTICAL = 0x0112;
const FKW_LESS_OR_EQUAL = 0x0113;
const FKW_LESS_THAN = 0x0114;
const FKW_MODULO_OPERATOR = 0x0115;
const FKW_MULTIPLY = 0x0116;
const FKW_NOT_EQUAL = 0x0117;
const FKW_NOT_IDENTICAL = 0x0118;
const FKW_POWER = 0x0119;
const FKW_PROMILAGE_OPERATOR = 0x011A;
const FKW_SQRT_OPERATOR = 0x011B;
const FKW_SQUARE_OPERATOR = 0x011C;
const FKW_STRING_CONCATENATION_OPERATOR = 0x011D;
const FKW_SUBTRACT = 0x011E;
const FKW_VALUE = 0x011F;

const FT_BOOLEAN = 0x00100000;
const FT_NUMBER = 0x00200000;
const FT_STRING = 0x00400000;

const FU_ANY = 0x00010000;
const FU_DERIVED = 0x00020000;
const FU_STRING = 0x00040000;



class ASTnode {
	constructor(n) {
		this.id = n;
	}

	setLocationInfo(loc) {
		this._yylloc = loc;
		return this;
	}
	setCommentsIndex(n) {
		this._commentIndex = n;
		return this;
	}
    setLexedText(s) {
    	this._lexedText = s;
		return this;
    }
}

class lexerToken extends ASTnode {
	constructor(n) {
		super(n);
	}
}

class ASTcurrency extends ASTnode {
	constructor(v) {
		super('$');
		this._currency = v;
	}
}

class ASTerror extends ASTnode {
	constructor(e, msg) {
		super('E');
		this._errorCode = e;
		this._errorMessage = msg;
	}
}

class ASTopcode extends ASTnode {
	constructor(n) {
		super('C');
		this.opcode = n;
	}
}

class ASTvalue extends ASTnode {
	constructor(v, a) {
		super('V');
		this._value = v;
		this._attributes = a;
	}
}


const symbolHashTable = {};


const parser = {
	getNextCommentIndex() {
		return getSemiRandomNumber();
	}
	dedupQuotedString(s, q) {
		return s;
	}
	deepCopy(loc) {
		// fake a deep clone with a shallow one:
		return Object.assign({}, loc);
	}
	getSymbol4Currency(s) {
		return '$$$' + s;		
	}
	getSymbol4DefinedConstant(s) {
		if (!symbolHashTable[s]) {
			let n = getSemiRandomNumber();
			symbolHashTable[s] = 'S' + n;
		}
		return symbolHashTable[s];
	}
	pushComment() {
		/**/
	}
}


//----------------------------------------------------------------------
//
// ShEx
// 

const ShExUtil = {
	unescapeText(s, delim) {
	  return s;
	}
};

const Parser = {

}

// End Of Include by Jison: includes/unicode.helpers.js`,
      },
    ],
    importDecls: [],
    unknownDecls: [],
    actionInclude: `/*
    ShapeMap parser in the Jison parser generator format.
  */

  //const ShapeMap = require("./ShapeMapSymbols");
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // WARNING: brutal hack to make example compile and run in minimal jison-gho lexer CLI environment.

  // Common namespaces and entities
  const XSD = 'http://www.w3.org/2001/XMLSchema#',
      XSD_INTEGER  = XSD + 'integer',
      XSD_DECIMAL  = XSD + 'decimal',
      XSD_FLOAT   = XSD + 'float',
      XSD_DOUBLE   = XSD + 'double',
      XSD_BOOLEAN  = XSD + 'boolean';

  const numericDatatypes = [
      XSD + "integer",
      XSD + "decimal",
      XSD + "float",
      XSD + "double",
      XSD + "string",
      XSD + "boolean",
      XSD + "dateTime",
      XSD + "nonPositiveInteger",
      XSD + "negativeInteger",
      XSD + "long",
      XSD + "int",
      XSD + "short",
      XSD + "byte",
      XSD + "nonNegativeInteger",
      XSD + "unsignedLong",
      XSD + "unsignedInt",
      XSD + "unsignedShort",
      XSD + "unsignedByte",
      XSD + "positiveInteger"
  ];

  const absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,
    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,
    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;

  const numericFacets = ["mininclusive", "minexclusive",
                       "maxinclusive", "maxexclusive"];

  // Extends a base object with properties of other objects
  function extend (base) {
    if (!base) base = {};
    for (let i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)
      for (let name in arg)
        base[name] = arg[name];
    return base;
  }

  // N3.js:lib/N3Parser.js<0.4.5>:58 with
  //   s/this\\./Parser./g
  // ### \`_setSchemaBase\` sets the base IRI to resolve relative IRIs.
  Parser._setSchemaBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._schemaBase = baseIRI) {
      Parser._schemaBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._schemaBaseRoot   = baseIRI[0];
      Parser._schemaBaseScheme = baseIRI[1];
    }
  }
  Parser._setDataBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._dataBase = baseIRI) {
      Parser._dataBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._dataBaseRoot   = baseIRI[0];
      Parser._dataBaseScheme = baseIRI[1];
    }
  }

  // N3.js:lib/N3Parser.js<0.4.5>:576 with
  //   s/this\\./Parser./g
  //   s/token/iri/
  // ### \`_resolveSchemaIRI\` resolves a relative IRI token against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative.
  function _resolveSchemaIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._schemaBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._schemaBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._schemaBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._schemaBaseScheme : Parser._schemaBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._schemaBasePath + iri);
    }
    }
  }
  function _resolveDataIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._dataBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._dataBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._dataBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._dataBaseScheme : Parser._dataBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._dataBasePath + iri);
    }
    }
  }

  // ### \`_removeDotSegments\` resolves './' and '../' path segments in an IRI as per RFC3986.
  function _removeDotSegments (iri) {
    // Don't modify the IRI if it does not contain any dot segments
    if (!dotSegments.test(iri))
      return iri;

    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'
    const result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';

    while (i < length) {
      switch (next) {
      // The path starts with the first slash after the authority
      case ':':
        if (pathStart < 0) {
          // Skip two slashes before the authority
          if (iri[++i] === '/' && iri[++i] === '/')
            // Skip to slash after the authority
            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')
              i = pathStart;
        }
        break;
      // Don't modify a query string or fragment
      case '?':
      case '#':
        i = length;
        break;
      // Handle '/.' or '/..' path segments
      case '/':
        if (iri[i + 1] === '.') {
          next = iri[++i + 1];
          switch (next) {
          // Remove a '/.' segment
          case '/':
            result += iri.substring(segmentStart, i - 1);
            segmentStart = i + 1;
            break;
          // Remove a trailing '/.' segment
          case undefined:
          case '?':
          case '#':
            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
          // Remove a '/..' segment
          case '.':
            next = iri[++i + 1];
            if (next === undefined || next === '/' || next === '?' || next === '#') {
              result += iri.substring(segmentStart, i - 2);
              // Try to remove the parent path from result
              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)
                result = result.substr(0, segmentStart);
              // Remove a trailing '/..' segment
              if (next !== '/')
                return result + '/' + iri.substr(i + 1);
              segmentStart = i + 1;
            }
          }
        }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  }

  function obj() {
    const ret = {  };
    for (let i = 0; i < arguments.length; i+= 2) {
      ret[arguments[i]] = arguments[i+1];
    }
    return ret;
  }

  // Creates a literal with the given value and type
  function createLiteral(value, type) {
    return obj("@value", value, "@type", type );
  }

  // Creates a new blank node identifier
  function blank() {
    return '_:b' + blankId++;
  };
  const blankId = 0;
  Parser._resetBlanks = function () { blankId = 0; }
  Parser.reset = function () {
    Parser._prefixes = Parser._imports = Parser.valueExprDefns = Parser.shapes = Parser.productions = Parser.start = Parser.startActs = null; // Reset state.
    Parser._schemaBase = Parser._schemaBasePath = Parser._schemaBaseRoot = Parser._schemaBaseIRIScheme = null;
  }
  let _fileName; // for debugging
  Parser._setFileName = function (fn) { _fileName = fn; }

  // Regular expression and replacement strings to escape strings
  const stringEscapeReplacements = { '\\\\': '\\\\', "'": "'", '"': '"',
                                   't': '\\t', 'b': '\\b', 'n': '\\n', 'r': '\\r', 'f': '\\f' },
      pnameEscapeReplacements = {
        '\\\\': '\\\\', "'": "'", '"': '"',
        'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',
        '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',
        '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',
        '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',
      };


  // Translates string escape codes in the string into their textual equivalent
  function unescapeString(string, trimLength) {
    string = string.substring(trimLength, string.length - trimLength);
    return obj("@value", unescapeText(string, stringEscapeReplacements));
  }

  function unescapeLangString(string, trimLength) {
    const at = string.lastIndexOf("@");
    const lang = string.substr(at);
    string = string.substr(0, at);
    const u = unescapeString(string, trimLength);
    return extend(u, obj("@language", lang.substr(1).toLowerCase()));
  }

  function error (msg) {
    Parser.reset();
    throw new Error(msg);
  }

  // Parse a prefix out of a PName or throw Error
  function parsePName (pname, prefixes) {
    const namePos = pname.indexOf(':');
    return expandPrefix(prefixes, pname.substr(0, namePos)) + unescapeText(pname.substr(namePos + 1), pnameEscapeReplacements);
  }

  // Expand declared prefix or throw Error
  function expandPrefix (prefixes, prefix) {
    if (!(prefix in prefixes))
      error('Parse error; unknown prefix: ' + prefix);
    return prefixes[prefix];
  }

  // Add a shape to the map
  function addShape (label, shape) {
    if (Parser.productions && label in Parser.productions)
      error("Structural error: "+label+" is a shape");
    if (!Parser.shapes)
      Parser.shapes = {};
    if (label in Parser.shapes) {
      if (Parser.options.duplicateShape === "replace")
        Parser.shapes[label] = shape;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.shapes[label] = shape;
  }

  // Add a production to the map
  function addProduction (label, production) {
    if (Parser.shapes && label in Parser.shapes)
      error("Structural error: "+label+" is a shape");
    if (!Parser.productions)
      Parser.productions = {};
    if (label in Parser.productions) {
      if (Parser.options.duplicateShape === "replace")
        Parser.productions[label] = production;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.productions[label] = production;
  }

  function shapeJunction (type, container, elts) {
    if (elts.length === 0) {
      return container;
    } else if (container.type === type) {
      container.shapeExprs = container.shapeExprs.concat(elts);
      return container;
    } else {
      return { type: type, shapeExprs: [container].concat(elts) };
    }
  }

  const EmptyObject = {  };
  const EmptyShape = { type: "Shape" };

  // <?INCLUDE from ShExUtil. Factor into \`rdf-token\` module? ?>
  /**
   * unescape numerics and allowed single-character escapes.
   * throws: if there are any unallowed sequences
   */
  function unescapeText (string, replacements) {
    const regex = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\(.)/g;
    try {
      string = string.replace(regex, function (sequence, unicode4, unicode8, escapedChar) {
        let charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return String.fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode < 0xFFFF) return String.fromCharCode(charCode);
          return String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        }
        else {
          const replacement = replacements[escapedChar];
          if (!replacement) throw new Error("no replacement found for '" + escapedChar + "'");
          return replacement;
        }
      });
      return string;
    }
    catch (error) { console.warn(error); return ''; }
  }`,
  },
  codeSections: [
    {
      qualifier: 'init',
      include: `// Included by Jison: includes/unicode.helpers.js:

// helper APIs for testing the unicode*.jisonlex lexer specs

// WARNING: this stuff is purely here so the example(s) will pass the default run test. You mileage will be NIL on these!

let predictive_random_seed = 5;

function getSemiRandomNumber() {
	predictive_random_seed = (predictive_random_seed * 31 + 7) % 51;	
	return predictive_random_seed;
}

// these are used in a three-way test in unicode2 spec:
function is_constant(str) {
	return getSemiRandomNumber() % 3 === 1;
}
function is_function(str) {
	return getSemiRandomNumber() % 3 === 2;
}



const FERR_UNTERMINATED_INLINE_COMMENT = 0x0100;
const FKA_COMMA = 0x0101;
const FKA_FIXED_ROW_OR_COLUMN_MARKER = 0x0102;
const FKA_RANGE_MARKER = 0x0103;
const FKW_ADD = 0x0104;
const FKW_ALMOST_EQUAL = 0x0105;
const FKW_ARRAY_CONCATENATION_OPERATOR = 0x0106;
const FKW_BOOLEAN_AND_OPERATOR = 0x0107;
const FKW_BOOLEAN_NOT_OPERATOR = 0x0108;
const FKW_BOOLEAN_OR_OPERATOR = 0x0109;
const FKW_CUBE_OPERATOR = 0x010A;
const FKW_DATA_MARKER = 0x010B;
const FKW_DEGREES_OPERATOR = 0x010C;
const FKW_DIVIDE = 0x010D;
const FKW_DOT = 0x010E;
const FKW_EQUAL = 0x010F;
const FKW_GREATER_OR_EQUAL = 0x0110;
const FKW_GREATER_THAN = 0x0111;
const FKW_IS_IDENTICAL = 0x0112;
const FKW_LESS_OR_EQUAL = 0x0113;
const FKW_LESS_THAN = 0x0114;
const FKW_MODULO_OPERATOR = 0x0115;
const FKW_MULTIPLY = 0x0116;
const FKW_NOT_EQUAL = 0x0117;
const FKW_NOT_IDENTICAL = 0x0118;
const FKW_POWER = 0x0119;
const FKW_PROMILAGE_OPERATOR = 0x011A;
const FKW_SQRT_OPERATOR = 0x011B;
const FKW_SQUARE_OPERATOR = 0x011C;
const FKW_STRING_CONCATENATION_OPERATOR = 0x011D;
const FKW_SUBTRACT = 0x011E;
const FKW_VALUE = 0x011F;

const FT_BOOLEAN = 0x00100000;
const FT_NUMBER = 0x00200000;
const FT_STRING = 0x00400000;

const FU_ANY = 0x00010000;
const FU_DERIVED = 0x00020000;
const FU_STRING = 0x00040000;



class ASTnode {
	constructor(n) {
		this.id = n;
	}

	setLocationInfo(loc) {
		this._yylloc = loc;
		return this;
	}
	setCommentsIndex(n) {
		this._commentIndex = n;
		return this;
	}
    setLexedText(s) {
    	this._lexedText = s;
		return this;
    }
}

class lexerToken extends ASTnode {
	constructor(n) {
		super(n);
	}
}

class ASTcurrency extends ASTnode {
	constructor(v) {
		super('$');
		this._currency = v;
	}
}

class ASTerror extends ASTnode {
	constructor(e, msg) {
		super('E');
		this._errorCode = e;
		this._errorMessage = msg;
	}
}

class ASTopcode extends ASTnode {
	constructor(n) {
		super('C');
		this.opcode = n;
	}
}

class ASTvalue extends ASTnode {
	constructor(v, a) {
		super('V');
		this._value = v;
		this._attributes = a;
	}
}


const symbolHashTable = {};


const parser = {
	getNextCommentIndex() {
		return getSemiRandomNumber();
	}
	dedupQuotedString(s, q) {
		return s;
	}
	deepCopy(loc) {
		// fake a deep clone with a shallow one:
		return Object.assign({}, loc);
	}
	getSymbol4Currency(s) {
		return '$$$' + s;		
	}
	getSymbol4DefinedConstant(s) {
		if (!symbolHashTable[s]) {
			let n = getSemiRandomNumber();
			symbolHashTable[s] = 'S' + n;
		}
		return symbolHashTable[s];
	}
	pushComment() {
		/**/
	}
}


//----------------------------------------------------------------------
//
// ShEx
// 

const ShExUtil = {
	unescapeText(s, delim) {
	  return s;
	}
};

const Parser = {

}

// End Of Include by Jison: includes/unicode.helpers.js`,
    },
  ],
  importDecls: [],
  unknownDecls: [],
  options: {
    moduleType: 'commonjs',
    debug: false,
    enableDebugLogs: false,
    json: true,
    noMain: true,
    moduleMain: null,
    moduleMainImports: null,
    dumpSourceCodeOnFailure: false,
    throwErrorOnCompileFailure: true,
    doNotTestCompile: false,
    defaultModuleName: 'lexer',
    xregexp: false,
    lexerErrorsAreRecoverable: false,
    flex: false,
    backtrack_lexer: false,
    ranges: false,
    trackPosition: true,
    caseInsensitive: false,
    exportSourceCode: {
      enabled: false,
    },
    exportAST: false,
    prettyCfg: true,
  },
  conditions: {
    INITIAL: {
      rules: [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        17,
        18,
        19,
        20,
        21,
        22,
        23,
        24,
        25,
        26,
        27,
        28,
        29,
        30,
        31,
        32,
        33,
        34,
        35,
        36,
        37,
        38,
        39,
        40,
      ],
      inclusive: true,
    },
  },
  performAction: `function lexer__performAction(yy, yyrulenumber, YY_START) {
            const yy_ = this;

            /*
    ShapeMap parser in the Jison parser generator format.
  */

  //const ShapeMap = require("./ShapeMapSymbols");
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // WARNING: brutal hack to make example compile and run in minimal jison-gho lexer CLI environment.

  // Common namespaces and entities
  const XSD = 'http://www.w3.org/2001/XMLSchema#',
      XSD_INTEGER  = XSD + 'integer',
      XSD_DECIMAL  = XSD + 'decimal',
      XSD_FLOAT   = XSD + 'float',
      XSD_DOUBLE   = XSD + 'double',
      XSD_BOOLEAN  = XSD + 'boolean';

  const numericDatatypes = [
      XSD + "integer",
      XSD + "decimal",
      XSD + "float",
      XSD + "double",
      XSD + "string",
      XSD + "boolean",
      XSD + "dateTime",
      XSD + "nonPositiveInteger",
      XSD + "negativeInteger",
      XSD + "long",
      XSD + "int",
      XSD + "short",
      XSD + "byte",
      XSD + "nonNegativeInteger",
      XSD + "unsignedLong",
      XSD + "unsignedInt",
      XSD + "unsignedShort",
      XSD + "unsignedByte",
      XSD + "positiveInteger"
  ];

  const absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,
    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,
    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;

  const numericFacets = ["mininclusive", "minexclusive",
                       "maxinclusive", "maxexclusive"];

  // Extends a base object with properties of other objects
  function extend (base) {
    if (!base) base = {};
    for (let i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)
      for (let name in arg)
        base[name] = arg[name];
    return base;
  }

  // N3.js:lib/N3Parser.js<0.4.5>:58 with
  //   s/this\\./Parser./g
  // ### \`_setSchemaBase\` sets the base IRI to resolve relative IRIs.
  Parser._setSchemaBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._schemaBase = baseIRI) {
      Parser._schemaBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._schemaBaseRoot   = baseIRI[0];
      Parser._schemaBaseScheme = baseIRI[1];
    }
  }
  Parser._setDataBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._dataBase = baseIRI) {
      Parser._dataBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._dataBaseRoot   = baseIRI[0];
      Parser._dataBaseScheme = baseIRI[1];
    }
  }

  // N3.js:lib/N3Parser.js<0.4.5>:576 with
  //   s/this\\./Parser./g
  //   s/token/iri/
  // ### \`_resolveSchemaIRI\` resolves a relative IRI token against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative.
  function _resolveSchemaIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._schemaBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._schemaBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._schemaBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._schemaBaseScheme : Parser._schemaBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._schemaBasePath + iri);
    }
    }
  }
  function _resolveDataIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._dataBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._dataBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._dataBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._dataBaseScheme : Parser._dataBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._dataBasePath + iri);
    }
    }
  }

  // ### \`_removeDotSegments\` resolves './' and '../' path segments in an IRI as per RFC3986.
  function _removeDotSegments (iri) {
    // Don't modify the IRI if it does not contain any dot segments
    if (!dotSegments.test(iri))
      return iri;

    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'
    const result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';

    while (i < length) {
      switch (next) {
      // The path starts with the first slash after the authority
      case ':':
        if (pathStart < 0) {
          // Skip two slashes before the authority
          if (iri[++i] === '/' && iri[++i] === '/')
            // Skip to slash after the authority
            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')
              i = pathStart;
        }
        break;
      // Don't modify a query string or fragment
      case '?':
      case '#':
        i = length;
        break;
      // Handle '/.' or '/..' path segments
      case '/':
        if (iri[i + 1] === '.') {
          next = iri[++i + 1];
          switch (next) {
          // Remove a '/.' segment
          case '/':
            result += iri.substring(segmentStart, i - 1);
            segmentStart = i + 1;
            break;
          // Remove a trailing '/.' segment
          case undefined:
          case '?':
          case '#':
            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
          // Remove a '/..' segment
          case '.':
            next = iri[++i + 1];
            if (next === undefined || next === '/' || next === '?' || next === '#') {
              result += iri.substring(segmentStart, i - 2);
              // Try to remove the parent path from result
              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)
                result = result.substr(0, segmentStart);
              // Remove a trailing '/..' segment
              if (next !== '/')
                return result + '/' + iri.substr(i + 1);
              segmentStart = i + 1;
            }
          }
        }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  }

  function obj() {
    const ret = {  };
    for (let i = 0; i < arguments.length; i+= 2) {
      ret[arguments[i]] = arguments[i+1];
    }
    return ret;
  }

  // Creates a literal with the given value and type
  function createLiteral(value, type) {
    return obj("@value", value, "@type", type );
  }

  // Creates a new blank node identifier
  function blank() {
    return '_:b' + blankId++;
  };
  const blankId = 0;
  Parser._resetBlanks = function () { blankId = 0; }
  Parser.reset = function () {
    Parser._prefixes = Parser._imports = Parser.valueExprDefns = Parser.shapes = Parser.productions = Parser.start = Parser.startActs = null; // Reset state.
    Parser._schemaBase = Parser._schemaBasePath = Parser._schemaBaseRoot = Parser._schemaBaseIRIScheme = null;
  }
  let _fileName; // for debugging
  Parser._setFileName = function (fn) { _fileName = fn; }

  // Regular expression and replacement strings to escape strings
  const stringEscapeReplacements = { '\\\\': '\\\\', "'": "'", '"': '"',
                                   't': '\\t', 'b': '\\b', 'n': '\\n', 'r': '\\r', 'f': '\\f' },
      pnameEscapeReplacements = {
        '\\\\': '\\\\', "'": "'", '"': '"',
        'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',
        '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',
        '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',
        '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',
      };


  // Translates string escape codes in the string into their textual equivalent
  function unescapeString(string, trimLength) {
    string = string.substring(trimLength, string.length - trimLength);
    return obj("@value", unescapeText(string, stringEscapeReplacements));
  }

  function unescapeLangString(string, trimLength) {
    const at = string.lastIndexOf("@");
    const lang = string.substr(at);
    string = string.substr(0, at);
    const u = unescapeString(string, trimLength);
    return extend(u, obj("@language", lang.substr(1).toLowerCase()));
  }

  function error (msg) {
    Parser.reset();
    throw new Error(msg);
  }

  // Parse a prefix out of a PName or throw Error
  function parsePName (pname, prefixes) {
    const namePos = pname.indexOf(':');
    return expandPrefix(prefixes, pname.substr(0, namePos)) + unescapeText(pname.substr(namePos + 1), pnameEscapeReplacements);
  }

  // Expand declared prefix or throw Error
  function expandPrefix (prefixes, prefix) {
    if (!(prefix in prefixes))
      error('Parse error; unknown prefix: ' + prefix);
    return prefixes[prefix];
  }

  // Add a shape to the map
  function addShape (label, shape) {
    if (Parser.productions && label in Parser.productions)
      error("Structural error: "+label+" is a shape");
    if (!Parser.shapes)
      Parser.shapes = {};
    if (label in Parser.shapes) {
      if (Parser.options.duplicateShape === "replace")
        Parser.shapes[label] = shape;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.shapes[label] = shape;
  }

  // Add a production to the map
  function addProduction (label, production) {
    if (Parser.shapes && label in Parser.shapes)
      error("Structural error: "+label+" is a shape");
    if (!Parser.productions)
      Parser.productions = {};
    if (label in Parser.productions) {
      if (Parser.options.duplicateShape === "replace")
        Parser.productions[label] = production;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.productions[label] = production;
  }

  function shapeJunction (type, container, elts) {
    if (elts.length === 0) {
      return container;
    } else if (container.type === type) {
      container.shapeExprs = container.shapeExprs.concat(elts);
      return container;
    } else {
      return { type: type, shapeExprs: [container].concat(elts) };
    }
  }

  const EmptyObject = {  };
  const EmptyShape = { type: "Shape" };

  // <?INCLUDE from ShExUtil. Factor into \`rdf-token\` module? ?>
  /**
   * unescape numerics and allowed single-character escapes.
   * throws: if there are any unallowed sequences
   */
  function unescapeText (string, replacements) {
    const regex = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\(.)/g;
    try {
      string = string.replace(regex, function (sequence, unicode4, unicode8, escapedChar) {
        let charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return String.fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode < 0xFFFF) return String.fromCharCode(charCode);
          return String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        }
        else {
          const replacement = replacements[escapedChar];
          if (!replacement) throw new Error("no replacement found for '" + escapedChar + "'");
          return replacement;
        }
      });
      return string;
    }
    catch (error) { console.warn(error); return ''; }
  }
const YYSTATE = YY_START;
switch(yyrulenumber) {
case 0 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       \\s+|{COMMENT} */ 
 /**/ 
break;
case 39 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       [a-zA-Z0-9_-]+ */ 
 return 'unexpected word "'+yy_.yytext+'"' 
break;
case 40 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       . */ 
 return 'invalid character '+yy_.yytext 
break;
default:
  return this.simpleCaseActionClusters[yyrulenumber];
}
        }`,
  caseHelperInclude: `{

  /*! Conditions:: INITIAL */ 
  /*! Rule::       {APPINFO_SPACE_COLON} */ 
   1 : 'APPINFO_SPACE_COLON',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {STRING_LITERAL2_COLON} */ 
   2 : 'STRING_LITERAL2_COLON',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {FOCUS} */ 
   3 : 'IT_FOCUS',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {START} */ 
   4 : 'START',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {ATSTART} */ 
   5 : 'ATSTART',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {IT_SPARQL} */ 
   6 : 'IT_SPARQL',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {ATPNAME_LN} */ 
   7 : 'ATPNAME_LN',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {ATPNAME_NS} */ 
   8 : 'ATPNAME_NS',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {LANGTAG} */ 
   9 : 'LANGTAG',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {PNAME_LN} */ 
   10 : 'PNAME_LN',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {APPINFO_COLON} */ 
   11 : 'APPINFO_COLON',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {PNAME_NS} */ 
   12 : 'PNAME_NS',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {DOUBLE} */ 
   13 : 'DOUBLE',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {DECIMAL} */ 
   14 : 'DECIMAL',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {INTEGER} */ 
   15 : 'INTEGER',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {IRIREF} */ 
   16 : 'IRIREF',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {BLANK_NODE_LABEL} */ 
   17 : 'BLANK_NODE_LABEL',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {STRING_LITERAL_LONG1} */ 
   18 : 'STRING_LITERAL_LONG1',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {STRING_LITERAL_LONG2} */ 
   19 : 'STRING_LITERAL_LONG2',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {STRING_LITERAL1} */ 
   20 : 'STRING_LITERAL1',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       {STRING_LITERAL2} */ 
   21 : 'STRING_LITERAL2',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       a */ 
   22 : 'IT_a',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       , */ 
   23 : 'GT_COMMA',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\{ */ 
   24 : 'GT_LCURLEY',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\} */ 
   25 : 'GT_RCURLEY',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       @ */ 
   26 : 'GT_AT',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       ! */ 
   27 : 'GT_NOT',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\? */ 
   28 : 'GT_OPT',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\/ */ 
   29 : 'GT_DIVIDE',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\$ */ 
   30 : 'GT_DOLLAR',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\[ */ 
   31 : 'GT_LBRACKET',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\] */ 
   32 : 'GT_RBRACKET',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       \\^\\^ */ 
   33 : 'GT_DTYPE',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       _ */ 
   34 : 'IT__',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       true */ 
   35 : 'IT_true',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       false */ 
   36 : 'IT_false',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       null */ 
   37 : 'IT_null',
  /*! Conditions:: INITIAL */ 
  /*! Rule::       $ */ 
   38 : 'EOF'
}`,
  rules: [
    {
      re: '/^(?:\\s+|(#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/))/',
      source: '^(?:\\s+|(#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\s+|(#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(appinfo[\\u0020\\u000A\\u0009]+:))/',
      source: '^(?:(appinfo[\\u0020\\u000A\\u0009]+:))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(appinfo[\\u0020\\u000A\\u0009]+:))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: `/^(?:("([^\\u0022\\u005C\\u000A\\u000D]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"[\\u0020\\u000A\\u0009]*:))/`,
      source: `^(?:("([^\\u0022\\u005C\\u000A\\u000D]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"[\\u0020\\u000A\\u0009]*:))`,
      flags: '',
      xregexp: {
        captureNames: null,
        source: `^(?:("([^\\u0022\\u005C\\u000A\\u000D]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"[\\u0020\\u000A\\u0009]*:))`,
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:([Ff][Oo][Cc][Uu][Ss]))/',
      source: '^(?:([Ff][Oo][Cc][Uu][Ss]))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:([Ff][Oo][Cc][Uu][Ss]))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:([Ss][Tt][Aa][Rr][Tt]))/',
      source: '^(?:([Ss][Tt][Aa][Rr][Tt]))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:([Ss][Tt][Aa][Rr][Tt]))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(@[Ss][Tt][Aa][Rr][Tt]))/',
      source: '^(?:(@[Ss][Tt][Aa][Rr][Tt]))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(@[Ss][Tt][Aa][Rr][Tt]))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:([Ss][Pp][Aa][Rr][Qq][Ll]))/',
      source: '^(?:([Ss][Pp][Aa][Rr][Qq][Ll]))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:([Ss][Pp][Aa][Rr][Qq][Ll]))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: "/^(?:(@(?:(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*))))/",
      source: "^(?:(@(?:(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*))))",
      flags: '',
      xregexp: {
        captureNames: null,
        source: "^(?:(@(?:(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*))))",
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(@(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)))/',
      source: '^(?:(@(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(@(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(@([A-Za-z])+((-([0-9A-Za-z])+))*))/',
      source: '^(?:(@([A-Za-z])+((-([0-9A-Za-z])+))*))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(@([A-Za-z])+((-([0-9A-Za-z])+))*))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: "/^(?:((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*)))/",
      source: "^(?:((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*)))",
      flags: '',
      xregexp: {
        captureNames: null,
        source: "^(?:((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*)))",
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(appinfo:))/',
      source: '^(?:(appinfo:))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(appinfo:))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:))/',
      source: '^(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(([+-])?((([0-9])+\\.([0-9])*((?:[Ee]([+-])?([0-9])+)))|((\\.)?([0-9])+((?:[Ee]([+-])?([0-9])+))))))/',
      source: '^(?:(([+-])?((([0-9])+\\.([0-9])*((?:[Ee]([+-])?([0-9])+)))|((\\.)?([0-9])+((?:[Ee]([+-])?([0-9])+))))))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(([+-])?((([0-9])+\\.([0-9])*((?:[Ee]([+-])?([0-9])+)))|((\\.)?([0-9])+((?:[Ee]([+-])?([0-9])+))))))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(([+-])?([0-9])*\\.([0-9])+))/',
      source: '^(?:(([+-])?([0-9])*\\.([0-9])+))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(([+-])?([0-9])*\\.([0-9])+))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(([+-])?([0-9])+))/',
      source: '^(?:(([+-])?([0-9])+))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(([+-])?([0-9])+))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*>))/',
      source: '^(?:(<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*>))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*>))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:(_:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|[0-9])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?))/',
      source: '^(?:(_:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|[0-9])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?))',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:(_:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|[0-9])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?))',
        flags: '',
        isNative: true,
      },
    },
    {
      re: `/^(?:('''(('|'')?([^\\'\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*'''))/`,
      source: `^(?:('''(('|'')?([^\\'\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*'''))`,
      flags: '',
      xregexp: {
        captureNames: null,
        source: `^(?:('''(('|'')?([^\\'\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*'''))`,
        flags: '',
        isNative: true,
      },
    },
    {
      re: `/^(?:("""(("|"")?([^\\"\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*"""))/`,
      source: `^(?:("""(("|"")?([^\\"\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*"""))`,
      flags: '',
      xregexp: {
        captureNames: null,
        source: `^(?:("""(("|"")?([^\\"\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*"""))`,
        flags: '',
        isNative: true,
      },
    },
    {
      re: `/^(?:('([^\\u0027\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*'))/`,
      source: `^(?:('([^\\u0027\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*'))`,
      flags: '',
      xregexp: {
        captureNames: null,
        source: `^(?:('([^\\u0027\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*'))`,
        flags: '',
        isNative: true,
      },
    },
    {
      re: `/^(?:("([^\\u0022\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"))/`,
      source: `^(?:("([^\\u0022\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"))`,
      flags: '',
      xregexp: {
        captureNames: null,
        source: `^(?:("([^\\u0022\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"))`,
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:a)/',
      source: '^(?:a)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:a)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:,)/',
      source: '^(?:,)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:,)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\{)/',
      source: '^(?:\\{)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\{)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\})/',
      source: '^(?:\\})',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\})',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:@)/',
      source: '^(?:@)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:@)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:!)/',
      source: '^(?:!)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:!)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\?)/',
      source: '^(?:\\?)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\?)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\/)/',
      source: '^(?:\\/)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\/)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\$)/',
      source: '^(?:\\$)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\$)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\[)/',
      source: '^(?:\\[)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\[)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\])/',
      source: '^(?:\\])',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\])',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:\\^\\^)/',
      source: '^(?:\\^\\^)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:\\^\\^)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:_)/',
      source: '^(?:_)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:_)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:true)/',
      source: '^(?:true)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:true)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:false)/',
      source: '^(?:false)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:false)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:null)/',
      source: '^(?:null)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:null)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:$)/',
      source: '^(?:$)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:$)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:[a-zA-Z0-9_-]+)/',
      source: '^(?:[a-zA-Z0-9_-]+)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:[a-zA-Z0-9_-]+)',
        flags: '',
        isNative: true,
      },
    },
    {
      re: '/^(?:.)/',
      source: '^(?:.)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:.)',
        flags: '',
        isNative: true,
      },
    },
  ],
  macros: {
    APPINFO_COLON: {
      in_set: 'a',
      elsewhere: 'appinfo:',
      raw: 'appinfo:',
    },
    APPINFO_SPACE_COLON: {
      in_set: {
        message: '[macro [APPINFO_SPACE_COLON] is unsuitable for use inside regex set expressions: "[appinfo[\\u0020\\u000A\\u0009]+:]"]',
        name: 'Error',
      },
      elsewhere: 'appinfo[\\u0020\\u000A\\u0009]+:',
      raw: 'appinfo[\\u0020\\u000A\\u0009]+:',
    },
    STRING_LITERAL2_COLON: {
      in_set: {
        message: `[macro [STRING_LITERAL2_COLON] is unsuitable for use inside regex set expressions: "["([^\\u0022\\u005C\\u000A\\u000D]|\\\\|\\\\)*"[\\u0020\\u000A\\u0009]*:]"]`,
        name: 'Error',
      },
      elsewhere: `"([^\\u0022\\u005C\\u000A\\u000D]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"[\\u0020\\u000A\\u0009]*:`,
      raw: '"([^\\u0022\\u005C\\u000A\\u000D]|{ECHAR}|{UCHAR})*"[\\u0020\\u000A\\u0009]*:',
    },
    ECHAR: {
      in_set: '\\\\',
      elsewhere: '\\\\[\\"\\\'\\\\bfnrt]',
      raw: '\\\\[\\"\\\'\\\\bfnrt]',
    },
    UCHAR: {
      in_set: '\\\\',
      elsewhere: '\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])',
      raw: '\\\\u{HEX}{HEX}{HEX}{HEX}|\\\\U{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}{HEX}',
    },
    HEX: {
      in_set: '0-9A-Fa-f',
      elsewhere: '[0-9]|[A-F]|[a-f]',
      raw: '[0-9]|[A-F]|[a-f]',
    },
    FOCUS: {
      in_set: 'Ff',
      elsewhere: '[Ff][Oo][Cc][Uu][Ss]',
      raw: '[Ff][Oo][Cc][Uu][Ss]',
    },
    START: {
      in_set: 'Ss',
      elsewhere: '[Ss][Tt][Aa][Rr][Tt]',
      raw: '[Ss][Tt][Aa][Rr][Tt]',
    },
    ATSTART: {
      in_set: '@',
      elsewhere: '@[Ss][Tt][Aa][Rr][Tt]',
      raw: '@[Ss][Tt][Aa][Rr][Tt]',
    },
    IT_SPARQL: {
      in_set: 'Ss',
      elsewhere: '[Ss][Pp][Aa][Rr][Qq][Ll]',
      raw: '[Ss][Pp][Aa][Rr][Qq][Ll]',
    },
    LANGTAG: {
      in_set: {
        message: '[macro [LANGTAG] is unsuitable for use inside regex set expressions: "[@([A-Za-z])+((-([0-9A-Za-z])+))*]"]',
        name: 'Error',
      },
      elsewhere: '@([A-Za-z])+((-([0-9A-Za-z])+))*',
      raw: '@([A-Za-z])+((-([0-9A-Za-z])+))*',
    },
    INTEGER: {
      in_set: {
        message: '[macro [INTEGER] is unsuitable for use inside regex set expressions: "[([+-])?([0-9])+]"]',
        name: 'Error',
      },
      elsewhere: '([+-])?([0-9])+',
      raw: '([+-])?([0-9])+',
    },
    DECIMAL: {
      in_set: {
        message: '[macro [DECIMAL] is unsuitable for use inside regex set expressions: "[([+-])?([0-9])*\\.([0-9])+]"]',
        name: 'Error',
      },
      elsewhere: '([+-])?([0-9])*\\.([0-9])+',
      raw: '([+-])?([0-9])*\\.([0-9])+',
    },
    EXPONENT: {
      in_set: {
        message: '[macro [EXPONENT] is unsuitable for use inside regex set expressions: "[[Ee]([+-])?([0-9])+]"]',
        name: 'Error',
      },
      elsewhere: '[Ee]([+-])?([0-9])+',
      raw: '[Ee]([+-])?([0-9])+',
    },
    DOUBLE: {
      in_set: {
        message: '[macro [EXPONENT] is unsuitable for use inside regex set expressions: "[[Ee]([+-])?([0-9])+]"]',
        name: 'Error',
      },
      elsewhere: '([+-])?((([0-9])+\\.([0-9])*((?:[Ee]([+-])?([0-9])+)))|((\\.)?([0-9])+((?:[Ee]([+-])?([0-9])+))))',
      raw: '([+-])?((([0-9])+\\.([0-9])*({EXPONENT}))|((\\.)?([0-9])+({EXPONENT})))',
    },
    PN_CHARS_BASE: {
      in_set: 'A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd',
      elsewhere: '[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]',
      raw: '[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF]',
    },
    PN_CHARS_U: {
      in_set: 'A_',
      elsewhere: '(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_',
      raw: '{PN_CHARS_BASE}|_|_',
    },
    PN_CHARS: {
      in_set: '\\-0-9A·̀-ͯ‿⁀',
      elsewhere: '(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]',
      raw: '{PN_CHARS_U}|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]',
    },
    BLANK_NODE_LABEL: {
      in_set: {
        message: '[macro [BLANK_NODE_LABEL] is unsuitable for use inside regex set expressions: "[_:(A_|[0-9])((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: '_:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|[0-9])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?',
      raw: '_:({PN_CHARS_U}|[0-9])(({PN_CHARS}|\\.)*{PN_CHARS})?',
    },
    PN_PREFIX: {
      in_set: {
        message: '[macro [PN_PREFIX] is unsuitable for use inside regex set expressions: "[A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: '(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?',
      raw: '{PN_CHARS_BASE}(({PN_CHARS}|\\.)*{PN_CHARS})?',
    },
    PNAME_NS: {
      in_set: {
        message: '[macro [PN_PREFIX] is unsuitable for use inside regex set expressions: "[A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: '(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:',
      raw: '{PN_PREFIX}?:',
    },
    ATPNAME_NS: {
      in_set: {
        message: '[macro [PN_PREFIX] is unsuitable for use inside regex set expressions: "[A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: '@(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)',
      raw: '@{PNAME_NS}',
    },
    PERCENT: {
      in_set: '%',
      elsewhere: '%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])',
      raw: '%{HEX}{HEX}',
    },
    STRING_LITERAL1: {
      in_set: {
        message: `[macro [STRING_LITERAL1] is unsuitable for use inside regex set expressions: "['([^\\u0027\\u005c\\u000a\\u000d]|\\\\|\\\\)*']"]`,
        name: 'Error',
      },
      elsewhere: `'([^\\u0027\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*'`,
      raw: "'([^\\u0027\\u005c\\u000a\\u000d]|{ECHAR}|{UCHAR})*'",
    },
    STRING_LITERAL2: {
      in_set: {
        message: `[macro [STRING_LITERAL2] is unsuitable for use inside regex set expressions: "["([^\\u0022\\u005c\\u000a\\u000d]|\\\\|\\\\)*"]"]`,
        name: 'Error',
      },
      elsewhere: `"([^\\u0022\\u005c\\u000a\\u000d]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*"`,
      raw: '"([^\\u0022\\u005c\\u000a\\u000d]|{ECHAR}|{UCHAR})*"',
    },
    STRING_LITERAL_LONG1: {
      in_set: {
        message: `[macro [STRING_LITERAL_LONG1] is unsuitable for use inside regex set expressions: "['''(('|'')?([^\\'\\\\]|\\\\|\\\\))*''']"]`,
        name: 'Error',
      },
      elsewhere: `'''(('|'')?([^\\'\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*'''`,
      raw: `'''(('|'')?([^\\'\\\\]|{ECHAR}|{UCHAR}))*'''`,
    },
    STRING_LITERAL_LONG2: {
      in_set: {
        message: `[macro [STRING_LITERAL_LONG2] is unsuitable for use inside regex set expressions: "["""(("|"")?([^\\"\\\\]|\\\\|\\\\))*"""]"]`,
        name: 'Error',
      },
      elsewhere: `"""(("|"")?([^\\"\\\\]|(?:\\\\[\\"\\'\\\\bfnrt])|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))))*"""`,
      raw: `"""(("|"")?([^\\"\\\\]|{ECHAR}|{UCHAR}))*"""`,
    },
    IRIREF: {
      in_set: {
        message: '[macro [IRIREF] is unsuitable for use inside regex set expressions: "[<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|\\\\)*>]"]',
        name: 'Error',
      },
      elsewhere: '<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|(?:\\\\u(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])|\\\\U(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f])))*>',
      raw: '<([^\\u0000-\\u0020<>\\"{}|^`\\\\]|{UCHAR})*>',
    },
    PN_LOCAL_ESC: {
      in_set: {
        message: `[macro [PN_LOCAL_ESC] is unsuitable for use inside regex set expressions: "[\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)]"]`,
        name: 'Error',
      },
      elsewhere: "\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)",
      raw: "\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)",
    },
    PLX: {
      in_set: {
        message: `[macro [PN_LOCAL_ESC] is unsuitable for use inside regex set expressions: "[\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)]"]`,
        name: 'Error',
      },
      elsewhere: "(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))",
      raw: '{PERCENT}|{PN_LOCAL_ESC}',
    },
    PN_LOCAL: {
      in_set: {
        message: `[macro [PN_LOCAL_ESC] is unsuitable for use inside regex set expressions: "[\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%)]"]`,
        name: 'Error',
      },
      elsewhere: "((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*",
      raw: '({PN_CHARS_U}|:|[0-9]|{PLX})({PN_CHARS}|\\.|:|{PLX})*',
    },
    PNAME_LN: {
      in_set: {
        message: '[macro [PN_PREFIX] is unsuitable for use inside regex set expressions: "[A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: "(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*)",
      raw: '{PNAME_NS}{PN_LOCAL}',
    },
    ATPNAME_LN: {
      in_set: {
        message: '[macro [PN_PREFIX] is unsuitable for use inside regex set expressions: "[A-Za-zÀ-ÖØ-öø-˿Ͱ-ͽͿ-῿‌‍⁰-↏Ⰰ-⿯、-\\udb7f豈-﷏ﷰ-\\ufffd((\\-0-9A·̀-ͯ‿⁀|\\.)*\\-0-9A·̀-ͯ‿⁀)?]"]',
        name: 'Error',
      },
      elsewhere: "@(?:(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])(((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.)*(?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040]))?)?:)(?:((?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|:|[0-9]|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))((?:(?:(?:[A-Z]|[a-z]|[\\u00c0-\\u00d6]|[\\u00d8-\\u00f6]|[\\u00f8-\\u02ff]|[\\u0370-\\u037d]|[\\u037f-\\u1fff]|[\\u200c-\\u200d]|[\\u2070-\\u218f]|[\\u2c00-\\u2fef]|[\\u3001-\\ud7ff]|[\\uf900-\\ufdcf]|[\\ufdf0-\\ufffd]|[\\uD800-\\uDB7F][\\uDC00-\\uDFFF])|_|_)|-|[0-9]|[\\u00b7]|[\\u0300-\\u036f]|[\\u203f-\\u2040])|\\.|:|(?:(?:%(?:[0-9]|[A-F]|[a-f])(?:[0-9]|[A-F]|[a-f]))|(?:\\\\(_|~|\\.|-|!|\\$|&|'|\\(|\\)|\\*|\\+|,|;|=|\\/|\\?|#|@|%))))*))",
      raw: '@{PNAME_LN}',
    },
    COMMENT: {
      in_set: {
        message: '[macro [COMMENT] is unsuitable for use inside regex set expressions: "[#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/]"]',
        name: 'Error',
      },
      elsewhere: '#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/',
      raw: '#[^\\u000a\\u000d]*|\\/\\*([^*]|\\*([^/]|\\\\\\/))*\\*\\/',
    },
  },
  regular_rule_count: 3,
  simple_rule_count: 38,
  conditionStack: [
    'INITIAL',
  ],
  actionInclude: `/*
    ShapeMap parser in the Jison parser generator format.
  */

  //const ShapeMap = require("./ShapeMapSymbols");
  // ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  // WARNING: brutal hack to make example compile and run in minimal jison-gho lexer CLI environment.

  // Common namespaces and entities
  const XSD = 'http://www.w3.org/2001/XMLSchema#',
      XSD_INTEGER  = XSD + 'integer',
      XSD_DECIMAL  = XSD + 'decimal',
      XSD_FLOAT   = XSD + 'float',
      XSD_DOUBLE   = XSD + 'double',
      XSD_BOOLEAN  = XSD + 'boolean';

  const numericDatatypes = [
      XSD + "integer",
      XSD + "decimal",
      XSD + "float",
      XSD + "double",
      XSD + "string",
      XSD + "boolean",
      XSD + "dateTime",
      XSD + "nonPositiveInteger",
      XSD + "negativeInteger",
      XSD + "long",
      XSD + "int",
      XSD + "short",
      XSD + "byte",
      XSD + "nonNegativeInteger",
      XSD + "unsignedLong",
      XSD + "unsignedInt",
      XSD + "unsignedShort",
      XSD + "unsignedByte",
      XSD + "positiveInteger"
  ];

  const absoluteIRI = /^[a-z][a-z0-9+.-]*:/i,
    schemeAuthority = /^(?:([a-z][a-z0-9+.-]*:))?(?:\\/\\/[^\\/]*)?/i,
    dotSegments = /(?:^|\\/)\\.\\.?(?:$|[\\/#?])/;

  const numericFacets = ["mininclusive", "minexclusive",
                       "maxinclusive", "maxexclusive"];

  // Extends a base object with properties of other objects
  function extend (base) {
    if (!base) base = {};
    for (let i = 1, l = arguments.length, arg; i < l && (arg = arguments[i] || {}); i++)
      for (let name in arg)
        base[name] = arg[name];
    return base;
  }

  // N3.js:lib/N3Parser.js<0.4.5>:58 with
  //   s/this\\./Parser./g
  // ### \`_setSchemaBase\` sets the base IRI to resolve relative IRIs.
  Parser._setSchemaBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._schemaBase = baseIRI) {
      Parser._schemaBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._schemaBaseRoot   = baseIRI[0];
      Parser._schemaBaseScheme = baseIRI[1];
    }
  }
  Parser._setDataBase = function (baseIRI) {
    if (!baseIRI)
      baseIRI = null;

    // baseIRI '#' check disabled to allow -x 'data:text/shex,...#'
    // else if (baseIRI.indexOf('#') >= 0)
    //   throw new Error('Invalid base IRI ' + baseIRI);

    // Set base IRI and its components
    if (Parser._dataBase = baseIRI) {
      Parser._dataBasePath   = baseIRI.replace(/[^\\/?]*(?:\\?.*)?$/, '');
      baseIRI = baseIRI.match(schemeAuthority);
      Parser._dataBaseRoot   = baseIRI[0];
      Parser._dataBaseScheme = baseIRI[1];
    }
  }

  // N3.js:lib/N3Parser.js<0.4.5>:576 with
  //   s/this\\./Parser./g
  //   s/token/iri/
  // ### \`_resolveSchemaIRI\` resolves a relative IRI token against the base path,
  // assuming that a base path has been set and that the IRI is indeed relative.
  function _resolveSchemaIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._schemaBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._schemaBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._schemaBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._schemaBaseScheme : Parser._schemaBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._schemaBasePath + iri);
    }
    }
  }
  function _resolveDataIRI (iri) {
    switch (iri[0]) {
    // An empty relative IRI indicates the base IRI
    case undefined: return Parser._dataBase;
    // Resolve relative fragment IRIs against the base IRI
    case '#': return Parser._dataBase + iri;
    // Resolve relative query string IRIs by replacing the query string
    case '?': return Parser._dataBase.replace(/(?:\\?.*)?$/, iri);
    // Resolve root-relative IRIs at the root of the base IRI
    case '/':
      // Resolve scheme-relative IRIs to the scheme
      return (iri[1] === '/' ? Parser._dataBaseScheme : Parser._dataBaseRoot) + _removeDotSegments(iri);
    // Resolve all other IRIs at the base IRI's path
    default: {
      return _removeDotSegments(Parser._dataBasePath + iri);
    }
    }
  }

  // ### \`_removeDotSegments\` resolves './' and '../' path segments in an IRI as per RFC3986.
  function _removeDotSegments (iri) {
    // Don't modify the IRI if it does not contain any dot segments
    if (!dotSegments.test(iri))
      return iri;

    // Start with an imaginary slash before the IRI in order to resolve trailing './' and '../'
    const result = '', length = iri.length, i = -1, pathStart = -1, segmentStart = 0, next = '/';

    while (i < length) {
      switch (next) {
      // The path starts with the first slash after the authority
      case ':':
        if (pathStart < 0) {
          // Skip two slashes before the authority
          if (iri[++i] === '/' && iri[++i] === '/')
            // Skip to slash after the authority
            while ((pathStart = i + 1) < length && iri[pathStart] !== '/')
              i = pathStart;
        }
        break;
      // Don't modify a query string or fragment
      case '?':
      case '#':
        i = length;
        break;
      // Handle '/.' or '/..' path segments
      case '/':
        if (iri[i + 1] === '.') {
          next = iri[++i + 1];
          switch (next) {
          // Remove a '/.' segment
          case '/':
            result += iri.substring(segmentStart, i - 1);
            segmentStart = i + 1;
            break;
          // Remove a trailing '/.' segment
          case undefined:
          case '?':
          case '#':
            return result + iri.substring(segmentStart, i) + iri.substr(i + 1);
          // Remove a '/..' segment
          case '.':
            next = iri[++i + 1];
            if (next === undefined || next === '/' || next === '?' || next === '#') {
              result += iri.substring(segmentStart, i - 2);
              // Try to remove the parent path from result
              if ((segmentStart = result.lastIndexOf('/')) >= pathStart)
                result = result.substr(0, segmentStart);
              // Remove a trailing '/..' segment
              if (next !== '/')
                return result + '/' + iri.substr(i + 1);
              segmentStart = i + 1;
            }
          }
        }
      }
      next = iri[++i];
    }
    return result + iri.substring(segmentStart);
  }

  function obj() {
    const ret = {  };
    for (let i = 0; i < arguments.length; i+= 2) {
      ret[arguments[i]] = arguments[i+1];
    }
    return ret;
  }

  // Creates a literal with the given value and type
  function createLiteral(value, type) {
    return obj("@value", value, "@type", type );
  }

  // Creates a new blank node identifier
  function blank() {
    return '_:b' + blankId++;
  };
  const blankId = 0;
  Parser._resetBlanks = function () { blankId = 0; }
  Parser.reset = function () {
    Parser._prefixes = Parser._imports = Parser.valueExprDefns = Parser.shapes = Parser.productions = Parser.start = Parser.startActs = null; // Reset state.
    Parser._schemaBase = Parser._schemaBasePath = Parser._schemaBaseRoot = Parser._schemaBaseIRIScheme = null;
  }
  let _fileName; // for debugging
  Parser._setFileName = function (fn) { _fileName = fn; }

  // Regular expression and replacement strings to escape strings
  const stringEscapeReplacements = { '\\\\': '\\\\', "'": "'", '"': '"',
                                   't': '\\t', 'b': '\\b', 'n': '\\n', 'r': '\\r', 'f': '\\f' },
      pnameEscapeReplacements = {
        '\\\\': '\\\\', "'": "'", '"': '"',
        'n': '\\n', 'r': '\\r', 't': '\\t', 'f': '\\f', 'b': '\\b',
        '_': '_', '~': '~', '.': '.', '-': '-', '!': '!', '$': '$', '&': '&',
        '(': '(', ')': ')', '*': '*', '+': '+', ',': ',', ';': ';', '=': '=',
        '/': '/', '?': '?', '#': '#', '@': '@', '%': '%',
      };


  // Translates string escape codes in the string into their textual equivalent
  function unescapeString(string, trimLength) {
    string = string.substring(trimLength, string.length - trimLength);
    return obj("@value", unescapeText(string, stringEscapeReplacements));
  }

  function unescapeLangString(string, trimLength) {
    const at = string.lastIndexOf("@");
    const lang = string.substr(at);
    string = string.substr(0, at);
    const u = unescapeString(string, trimLength);
    return extend(u, obj("@language", lang.substr(1).toLowerCase()));
  }

  function error (msg) {
    Parser.reset();
    throw new Error(msg);
  }

  // Parse a prefix out of a PName or throw Error
  function parsePName (pname, prefixes) {
    const namePos = pname.indexOf(':');
    return expandPrefix(prefixes, pname.substr(0, namePos)) + unescapeText(pname.substr(namePos + 1), pnameEscapeReplacements);
  }

  // Expand declared prefix or throw Error
  function expandPrefix (prefixes, prefix) {
    if (!(prefix in prefixes))
      error('Parse error; unknown prefix: ' + prefix);
    return prefixes[prefix];
  }

  // Add a shape to the map
  function addShape (label, shape) {
    if (Parser.productions && label in Parser.productions)
      error("Structural error: "+label+" is a shape");
    if (!Parser.shapes)
      Parser.shapes = {};
    if (label in Parser.shapes) {
      if (Parser.options.duplicateShape === "replace")
        Parser.shapes[label] = shape;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.shapes[label] = shape;
  }

  // Add a production to the map
  function addProduction (label, production) {
    if (Parser.shapes && label in Parser.shapes)
      error("Structural error: "+label+" is a shape");
    if (!Parser.productions)
      Parser.productions = {};
    if (label in Parser.productions) {
      if (Parser.options.duplicateShape === "replace")
        Parser.productions[label] = production;
      else if (Parser.options.duplicateShape !== "ignore")
        error("Parse error: "+label+" already defined");
    } else
      Parser.productions[label] = production;
  }

  function shapeJunction (type, container, elts) {
    if (elts.length === 0) {
      return container;
    } else if (container.type === type) {
      container.shapeExprs = container.shapeExprs.concat(elts);
      return container;
    } else {
      return { type: type, shapeExprs: [container].concat(elts) };
    }
  }

  const EmptyObject = {  };
  const EmptyShape = { type: "Shape" };

  // <?INCLUDE from ShExUtil. Factor into \`rdf-token\` module? ?>
  /**
   * unescape numerics and allowed single-character escapes.
   * throws: if there are any unallowed sequences
   */
  function unescapeText (string, replacements) {
    const regex = /\\\\u([a-fA-F0-9]{4})|\\\\U([a-fA-F0-9]{8})|\\\\(.)/g;
    try {
      string = string.replace(regex, function (sequence, unicode4, unicode8, escapedChar) {
        let charCode;
        if (unicode4) {
          charCode = parseInt(unicode4, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          return String.fromCharCode(charCode);
        }
        else if (unicode8) {
          charCode = parseInt(unicode8, 16);
          if (isNaN(charCode)) throw new Error(); // can never happen (regex), but helps performance
          if (charCode < 0xFFFF) return String.fromCharCode(charCode);
          return String.fromCharCode(0xD800 + ((charCode -= 0x10000) >> 10), 0xDC00 + (charCode & 0x3FF));
        }
        else {
          const replacement = replacements[escapedChar];
          if (!replacement) throw new Error("no replacement found for '" + escapedChar + "'");
          return replacement;
        }
      });
      return string;
    }
    catch (error) { console.warn(error); return ''; }
  }`,
  moduleInclude: '',
  __in_rules_failure_analysis_mode__: false,
  is_custom_lexer: false,
}