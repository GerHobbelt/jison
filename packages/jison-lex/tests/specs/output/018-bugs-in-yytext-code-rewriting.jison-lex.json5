
//=============================================================================
//                     JISON-LEX OPTIONS:

{
  lexerActionsUseYYLENG: '???',
  lexerActionsUseYYLINENO: '???',
  lexerActionsUseYYTEXT: '???',
  lexerActionsUseYYLOC: '???',
  lexerActionsUseParseError: '???',
  lexerActionsUseYYERROR: '???',
  lexerActionsUseLocationTracking: '???',
  lexerActionsUseMore: '???',
  lexerActionsUseUnput: '???',
  lexerActionsUseReject: '???',
  lexerActionsUseLess: '???',
  lexerActionsUseDisplayAPIs: '???',
  lexerActionsUseDescribeYYLOC: '???',
  lex_rule_dictionary: {
    rules: [
      {
        ast: {
          source: '[IDEM: srcCode]',
          augmentedSource: '[LINE-SHIFTED SOURCE]',
          ast: '[recast AST]',
          fault: false,
        },
        fault: false,
        srcCode: `// API Note:
        //
        // *all* \`yyerror()\` functions are expected to either return a token ID or throw an exception...
        //
        // Aside: by default, when your custom parseError() doesn't return a token ID, the token 'ERROR'
        // will be produced instead.
        //
        return yyerror(\`'${yytext[0]}' (${yytext.charCodeAt(0)}): illegal character at line ${yylineno}.\`)`,
        rule: '.',
      },
    ],
    macros: {},
    startConditions: {},
    codeSections: [],
    importDecls: [],
    unknownDecls: [],
    actionInclude: `// Normally, I would have dumped this piece of setup at the end of the spec, past the last '%%',
    // BUT the test rig DOES NOT include that part into the generated lexer used for testing.  :-(

    yy.parseError = function custom_parseError(str, hash, ExceptionClass) {
        if (0) console.error("invoking custom parseError:", {str, yyrulenumber});
        
        // ,---- *none* of the three 'yytext' identifiers below should be exapanded!
        if (str === 'bogus-condition-to-prevent-runtime-crash') {
            this.yytext = {
                "yytext": this.yytext,
                message: str,
                yyrulenumber
            };
        } else {
            // both these 'yytext' identifiers SHOULD be expanded and will access the yy_ in the performAction() closure.
            yytext = {
                text: yytext,
                message: str,
                yyrulenumber
            };
        }
        return 666;
    }`,
  },
  codeSections: [],
  importDecls: [],
  unknownDecls: [],
  options: {
    moduleType: 'commonjs',
    debug: false,
    enableDebugLogs: false,
    json: true,
    noMain: true,
    moduleMain: null,
    moduleMainImports: null,
    dumpSourceCodeOnFailure: false,
    throwErrorOnCompileFailure: true,
    doNotTestCompile: false,
    defaultModuleName: 'lexer',
    xregexp: false,
    lexerErrorsAreRecoverable: false,
    flex: false,
    backtrack_lexer: false,
    ranges: false,
    trackPosition: true,
    caseInsensitive: false,
    exportSourceCode: {
      enabled: false,
    },
    exportAST: false,
    prettyCfg: true,
  },
  conditions: {
    INITIAL: {
      rules: [
        0,
      ],
      inclusive: true,
    },
  },
  performAction: `function lexer__performAction(yy, yyrulenumber, YY_START) {
            const yy_ = this;

            // Normally, I would have dumped this piece of setup at the end of the spec, past the last '%%',
    // BUT the test rig DOES NOT include that part into the generated lexer used for testing.  :-(

    yy.parseError = function custom_parseError(str, hash, ExceptionClass) {
        if (0) console.error("invoking custom parseError:", {str, yyrulenumber});
        
        // ,---- *none* of the three 'yy_.yytext' identifiers below should be exapanded!
        if (str === 'bogus-condition-to-prevent-runtime-crash') {
            this.yy_.yytext = {
                "yy_.yytext": this.yy_.yytext,
                message: str,
                yyrulenumber
            };
        } else {
            // both these 'yy_.yytext' identifiers SHOULD be expanded and will access the yy_ in the performAction() closure.
            yy_.yytext = {
                text: yy_.yytext,
                message: str,
                yyrulenumber
            };
        }
        return 666;
    }
const YYSTATE = YY_START;
switch(yyrulenumber) {
case 0 : 
/*! Conditions:: INITIAL */ 
/*! Rule::       . */ 
 // API Note:
        //
        // *all* \`yy_.yyerror()\` functions are expected to either return a token ID or throw an exception...
        //
        // Aside: by default, when your custom parseError() doesn't return a token ID, the token 'ERROR'
        // will be produced instead.
        //
        return yy_.yyerror(\`'${yy_.yytext[0]}' (${yy_.yytext.charCodeAt(0)}): illegal character at line ${yy_.yylineno}.\`) 
break;
}
        }`,
  caseHelperInclude: `{

}`,
  rules: [
    {
      re: '/^(?:.)/',
      source: '^(?:.)',
      flags: '',
      xregexp: {
        captureNames: null,
        source: '^(?:.)',
        flags: '',
        isNative: true,
      },
    },
  ],
  macros: {},
  regular_rule_count: 1,
  simple_rule_count: 0,
  conditionStack: [
    'INITIAL',
  ],
  actionInclude: `// Normally, I would have dumped this piece of setup at the end of the spec, past the last '%%',
    // BUT the test rig DOES NOT include that part into the generated lexer used for testing.  :-(

    yy.parseError = function custom_parseError(str, hash, ExceptionClass) {
        if (0) console.error("invoking custom parseError:", {str, yyrulenumber});
        
        // ,---- *none* of the three 'yytext' identifiers below should be exapanded!
        if (str === 'bogus-condition-to-prevent-runtime-crash') {
            this.yytext = {
                "yytext": this.yytext,
                message: str,
                yyrulenumber
            };
        } else {
            // both these 'yytext' identifiers SHOULD be expanded and will access the yy_ in the performAction() closure.
            yytext = {
                text: yytext,
                message: str,
                yyrulenumber
            };
        }
        return 666;
    }`,
  moduleInclude: '',
  __in_rules_failure_analysis_mode__: false,
  is_custom_lexer: false,
}