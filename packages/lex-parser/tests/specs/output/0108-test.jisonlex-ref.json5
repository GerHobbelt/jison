{
  rules: [
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: `// followed by another operator, i.e. anything that's 
                      // not a number, or The End: then this is a unary 
                      // \`percent\` operator.
                      //
                      // \`1%-2\` would be ambiguous but isn't: the \`-\` is 
                      // considered as a unary minus and thus \`%\` is a 
                      // \`modulo\` operator.
                      //
                      // \`1%*5\` thus is treated the same: any operator 
                      // following the \`%\` is assumed to be a *binary* 
                      // operator. Hence \`1% times 5\` which brings us to 
                      // operators which only exist in unary form: \`!\`, and 
                      // values which are not numbers, e.g. \`PI\` and \`E\`:
                      // how about
                      // - \`1%E\` -> modulo E,
                      // - \`1%!0\` -> modulo 1 (as !0 -> 1)
                      //
                      // Of course, the easier way to handle this would be to 
                      // keep the lexer itself dumb and put this additional 
                      // logic inside a post_lex handler which should then be 
                      // able to obtain additional look-ahead tokens and queue 
                      // them for later, while using those to inspect and 
                      // adjust the lexer output now -- a trick which is used 
                      // in the cockroachDB SQL parser code, for example.
                      //
                      // The above regex solution however is a more local 
                      // extra-lookahead solution and thus should cost us less 
                      // overhead than the suggested post_lex alternative, but 
                      // it comes at a cost itself: complex regex and 
                      // duplication of language knowledge in the lexer itself, 
                      // plus inclusion of *grammar* (syntactic) knowledge in 
                      // the lexer too, where it doesn't belong in an ideal 
                      // world...
                      console.log('percent: ', yytext);
                      return '%'`,
      rule: '%(?=\\s*(?:[^0-9)]|E\\b|PI\\b|$))',
      start_condition: [
        'PERCENT_ALLOWED',
      ],
    },
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: `this.popState(); 
                      this.unput(yytext); 
                      // this.unput(yytext); can be used here instead of 
                      // this.reject(); which would only work when we set the 
                      // \`backtrack_lexer\` option`,
      rule: '.',
      start_condition: [
        'PERCENT_ALLOWED',
      ],
    },
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: '/* skip whitespace */',
      rule: '\\s+',
    },
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: `this.pushState('PERCENT_ALLOWED'); 
                      return 'NUMBER'`,
      rule: '[0-9]+(\\.[0-9]+)?\\b',
    },
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: "return 'EOF'",
      rule: '$',
    },
    {
      ast: {
        source: '[IDEM: srcCode]',
        augmentedSource: '[LINE-SHIFTED SOURCE]',
        ast: '[recast AST]',
        fault: false,
      },
      fault: false,
      srcCode: "return 'CHAR'",
      rule: '.',
    },
  ],
  macros: {},
  startConditions: {
    PERCENT_ALLOWED: 0,
  },
  codeSections: [],
  importDecls: [],
  unknownDecls: [],
  __extra_diag_info__: {
    pre_parse_callback_callCount: 1,
    post_parse_callback_callCount: 1,
    post_parse_diaginfo: {
      sharedState_yy: {
        startConditions: '[reference to sibling --> *.startConditions]',
        __options_flags__: 0,
        __options_category_description__: '???',
        __inside_scoped_ruleset__: false,
        __context_cfg_stack__: [],
        __inside_condition_set__: false,
        depth: 0,
        include_command_allowed: false,
      },
      hash: {
        errStr: null,
        exception: null,
        text: '',
        value: '',
        token: '"$accept"',
        token_id: 0,
        line: 74,
        expected: null,
        recoverable: false,
        state: 26,
        action: 2,
        new_state: 1,
        stack_pointer: 5,
      },
      reentrant_call_depth: 1,
      error_infos_stack: [
        {
          errStr: null,
          exception: null,
          text: '',
          value: '',
          token: '"$accept"',
          token_id: 0,
          line: 74,
          expected: null,
          recoverable: false,
          state: 26,
          action: 2,
          new_state: 1,
          stack_pointer: 5,
        },
      ],
      error_recovery_stack: [],
      error_infos_stack_size: 1,
      error_recovery_stack_size: 0,
    },
    reentrant_call_depth: 0,
    error_infos_stack_size: 0,
    error_recovery_stack_size: 0,
  },
  __original_input__: `//
// title: "regression of bare action code chunk parsing"
// test_input: 5% E 21.5       % Z99
//
// ...
//

%s PERCENT_ALLOWED

%%

// \`%\`: the grammar is not LALR(1) unless we make the lexer smarter and have 
// it disambiguate the \`%\` between \`percent\` and \`modulo\` functionality by 
// additional look-ahead:
// we introduce a lexical predicate here to disambiguate the \`%\` and thus 
// keep the grammar LALR(1)!
//      https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions
// we also use an (inclusive) lexical scope which turns this rule on only 
// immediately after a number was lexed previously.

<PERCENT_ALLOWED>"%"(?=\\s*(?:[^0-9)]|E\\b|PI\\b|$))
                      // followed by another operator, i.e. anything that's 
                      // not a number, or The End: then this is a unary 
                      // \`percent\` operator.
                      //
                      // \`1%-2\` would be ambiguous but isn't: the \`-\` is 
                      // considered as a unary minus and thus \`%\` is a 
                      // \`modulo\` operator.
                      //
                      // \`1%*5\` thus is treated the same: any operator 
                      // following the \`%\` is assumed to be a *binary* 
                      // operator. Hence \`1% times 5\` which brings us to 
                      // operators which only exist in unary form: \`!\`, and 
                      // values which are not numbers, e.g. \`PI\` and \`E\`:
                      // how about
                      // - \`1%E\` -> modulo E,
                      // - \`1%!0\` -> modulo 1 (as !0 -> 1)
                      //
                      // Of course, the easier way to handle this would be to 
                      // keep the lexer itself dumb and put this additional 
                      // logic inside a post_lex handler which should then be 
                      // able to obtain additional look-ahead tokens and queue 
                      // them for later, while using those to inspect and 
                      // adjust the lexer output now -- a trick which is used 
                      // in the cockroachDB SQL parser code, for example.
                      //
                      // The above regex solution however is a more local 
                      // extra-lookahead solution and thus should cost us less 
                      // overhead than the suggested post_lex alternative, but 
                      // it comes at a cost itself: complex regex and 
                      // duplication of language knowledge in the lexer itself, 
                      // plus inclusion of *grammar* (syntactic) knowledge in 
                      // the lexer too, where it doesn't belong in an ideal 
                      // world...
                      console.log('percent: ', yytext);
                      return '%';

<PERCENT_ALLOWED>.                     
                      this.popState(); 
                      this.unput(yytext); 
                      // this.unput(yytext); can be used here instead of 
                      // this.reject(); which would only work when we set the 
                      // \`backtrack_lexer\` option




\\s+                   /* skip whitespace */

[0-9]+("."[0-9]+)?\\b  
                      this.pushState('PERCENT_ALLOWED'); 
                      return 'NUMBER';

<<EOF>>               return 'EOF';
.                     return 'CHAR';`,
}