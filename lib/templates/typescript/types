
type ParseErrorType = (str:string, hash:any) => void;
interface LexerType {
  EOF: number;
  parseError: ParseErrorType;
  setInput: (input: string, yy:any ) => void;
  input: () => void;
  unput: (str:string) => void;
  more: () => LexerType;
  // less: (n:number): string;
  pastInput: () => string;
  upcomingInput: () => string;
  showPosition: () => string;
  test_match: (regex_match_array:any, rule_index:any) => boolean;
  // next: function();
  lex: () => any;
  begin: (condition: string) => void;
  popState: () => any;
  _currentRules: () => any;
  topState: (n:number) => string;
  pushState: (condition: any) => void;
  options: {
    ranges?: boolean; //           (optional: true ==> token location info will include a .range[] member)
    flex?: boolean; //             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
    backtrack_lexer?: boolean;  // (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
  };

  performAction: (yy: any, yy_: any, $avoiding_name_collisions: any, YY_START: any) => any;
  rules: any[];
  conditions: {[name: string]: any /* set */ };
  yy?: any;
  _input?: any;
  _more?: any;
  _backtrack?: any;
  reject: any;
  less: any;
  next: any;
  stateStackSize: any;
}
interface TokenLocation {
  first_line: number;
  first_column: number;
  last_line: number;
  last_column: number;
  range?: [number, number];
}
interface StateType {
  [key:number]: number
}
interface ParserType {
  trace: (str?:string) => void;
  yy: any;
  $?: any;
  table: Array<StateType>;
  defaultActions: any;
  symbols_: any;
  terminals_: {[key:number]: string};
  productions_: any;
  performAction: (yytext:any, yyleng:any, yylineno:any, yy:any, yystate:any /* action[1] */, $$:any /* vstack */, _$:any /* lstack */) => any;
  parseError: ParseErrorType;
  parse: (input: string) => void;
  lexer?: any;
  Parser?: any;
}
